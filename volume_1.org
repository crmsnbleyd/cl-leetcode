#+title: Common Lisp solutions to problems x to y
#+author: Arnav Andrew Jose

* 1. Two Sum
A fairly simple optimised solution (algorithmically, at least. Not sure if idiomatic CL) that uses hash-table.
Checks if the target is the double of the current number and only returns if another instance of the number exists in the input list.

#+BEGIN_SRC lisp :tangle solutions/two-sum.lisp
  (defun two-sum (nums target)
    (let ((hash (make-hash-table))
	  (iter-hash-item nil))
      (loop for x in nums and idx from 0
	    do (setf (gethash x hash) (cons idx (gethash x hash))))
      (loop for k being each hash-key of hash
	    do (when (setf iter-hash-item (gethash (- target k) hash))
		 (unless (and (= target (* k 2)) (not (cdr iter-hash-item)))
		   (return-from two-sum (car iter-hash-item)))))))
#+END_SRC

* 2. Add Two Numbers
Lisp already has linked lists, isn't that swell? I would like to do this recursively, but the ANSI standard does not specify Tail Call Optimization, and so I shall search for a LOOP based solution.
#+BEGIN_SRC lisp :tangle solutions/add-two-numbers.lisp
#+END_SRC

* 3. Longest Substring Without Repeating Characters
A pretty ugly, procedural solution translated directly from one written in Python. This wouldn't fly in Scheme or Clojure.
I kept running into arcane errors because I was using `do` instead of  `progn`.

#+BEGIN_SRC lisp :tangle solutions/largest-substring.lisp
  (defun longest-substr (s)
    (let ((longest 0)
	  (curr 0)
	  (start 0)
	  (seen (make-hash-table))
	  (len (length s)))
      (loop for idx from 0 to (- len 1) do
	(if (gethash (char s idx) seen)
	    (progn
	     (setf longest (max longest curr))
	     (loop while (char/= (char s start) (char s idx)) do
	       (remhash (char s start) seen)
	       (incf start))
	      (incf start)
	      (setf curr (+ 1 (- idx start))))
	    (progn
	     (setf (gethash (char s idx) seen) t)
	     (incf curr))))
      (setf longest (max longest curr))
      longest))
#+END_SRC
